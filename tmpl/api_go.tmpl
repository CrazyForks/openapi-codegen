{{define "header"}}
package {{Variable .Variables "apiPackage"}};

import "fmt"
{{end}}

{{define "struct"}}
// {{.Name}} {{if .Description}}{{.Description}}{{else}}{{.Type.Expression}}{{end}}
type {{.Type.Expression}} struct {
	{{range $val :=.Properties -}}
	{{CapitalizeLetter $val.Name}}  {{$val.Type.Expression}}  `json:"{{$val.Name}},omitempty"` //{{$val.Description}}
	{{end}}
}
{{end}}


{{define "path"}}

// {{CapitalizeLetter .Tag}}{{CapitalizeLetter .Name}} {{.Path}}
type {{CapitalizeLetter .Tag}}{{CapitalizeLetter .Name}} struct {
    Client ApiClient[{{.Response.Expression}}]
}

// Call {{.Description}}
func (receiver *{{CapitalizeLetter .Tag}}{{CapitalizeLetter .Name}}) Call({{template "parameters" .}}) ({{.Response.Expression}}, error) {
    {{if .Queries}}
    params := map[string]any{}
    {{range $idx,$val := .Queries -}}
    params["{{$val.Name}}"] = {{$val.Alias}}
    {{end -}}
    {{- else -}}
    {{if .Request}}{{else}}params := map[string]any{}{{end}}
    {{- end}}
    return receiver.Client.{{CapitalizeLetter .Method}}({{.Path}}, {{- if .Request}}body{{else}}params{{end}})
}
{{end}}


{{define "parameters"}}
{{- range $idx,$val := .Parameters -}}{{if gt $idx 0}},{{end}} {{$val.Alias}} {{$val.Type.Expression}}{{- end -}}
{{end}}

{{define "api"}}
    	{{range $val :=.Paths -}}
    	{{template "path" $val}}
    	{{end}}
{{end}}


{{define "client"}}
package {{Variable .Variables "clientPackage"}}

import (
	"bytes"
	"encoding/json"
	"fmt"
	"io"
	"net/http"
	"net/url"
)


// ApiClient TODO You need to implement the current interface
type ApiClient[T any] interface {
	Get(name string, params map[string]any) (T, error)

	Post(name string, params any) (T, error)

	Put(name string, params any) (T, error)

	Delete(name string, params any) (T, error)
}

type DefaultClient[T any] struct {
	Host    string
	Headers http.Header
}

func NewClient[T any](host string, headers http.Header) ApiClient[T] {
	return &DefaultClient[T]{host, headers}
}

func (t *DefaultClient[T]) Get(name string, params map[string]any) (T, error) {

	uri, _ := url.Parse(t.Host)
	uri.Path = name

	if params != nil {
		query := url.Values{}
		for k, v := range params {
			query.Set(k, fmt.Sprintf("%v", v))
		}
		uri.RawQuery = query.Encode()
	}

	req := &http.Request{
		Method: http.MethodGet,
		URL:    uri,
		Header: t.Headers,
	}

	return t.request(req)
}

func (t *DefaultClient[T]) Post(name string, params any) (T, error) {
	return t.doBody(http.MethodPost, name, params)
}

func (t *DefaultClient[T]) Put(name string, params any) (T, error) {
	return t.doBody(http.MethodPut, name, params)
}

func (t *DefaultClient[T]) Delete(name string, params any) (T, error) {
	return t.doBody(http.MethodDelete, name, params)
}

func (t *DefaultClient[T]) doBody(method string, name string, params any) (T, error) {
	uri, _ := url.Parse(t.Host)
	uri.JoinPath(name)

	req := &http.Request{
		Method: method,
		URL:    uri,
		Header: t.Headers,
	}

	if params != nil {
		body, _ := json.Marshal(params)
		req.Body = io.NopCloser(bytes.NewBuffer(body))
	}

	return t.request(req)
}
func (t *DefaultClient[T]) request(req *http.Request) (T, error) {

	var ret T

	// call
	resp, err := http.DefaultClient.Do(req)
	if err != nil {
		return ret, err
	}

	// read response
	defer func() {
		_ = resp.Body.Close()
	}()
	body, err := io.ReadAll(resp.Body)
	if err != nil {
		return ret, err
	}

	//decode
	err = json.Unmarshal(body, &ret)
	if err != nil {
		return ret, err
	}
	return ret, nil
}
{{end}}